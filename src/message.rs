// This file is @generated by ppsc-build.
extern crate alloc;
use parity_scale_codec::{Encode, Decode};

/// *
/// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
/// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
#[derive(Encode, Decode)]
pub struct Message {
    /// Contents of the message
    pub data: Option<MessageData>,
    /// Hash digest of data
    pub hash: alloc::vec::Vec<u8>,
    /// Hash scheme that produced the hash digest
    pub hash_scheme: i32,
    /// Signature of the hash digest
    pub signature: alloc::vec::Vec<u8>,
    /// Signature scheme that produced the signature
    pub signature_scheme: i32,
    /// Public key or address of the key pair that produced the signature
    pub signer: alloc::vec::Vec<u8>,
    /// MessageData serialized to bytes if using protobuf serialization other than ts-proto
    pub data_bytes: Option<alloc::vec::Vec<u8>>,
}
/// *
/// A MessageData object contains properties common to all messages and wraps a body object which
/// contains properties specific to the MessageType.
#[derive(Encode, Decode)]
pub struct MessageData {
    /// Type of message contained in the body
    pub r#type: i32,
    /// Farcaster ID of the user producing the message
    pub fid: u64,
    /// Farcaster epoch timestamp in seconds
    pub timestamp: u32,
    /// Farcaster network the message is intended for
    pub network: i32,
    pub body: Option<message_data::Body>,
}
/// Nested message and enum types in `MessageData`.
pub mod message_data {
    use super::*;

        #[derive(Encode, Decode)]
    pub enum Body {
        CastAddBody(super::CastAddBody),
        CastRemoveBody(super::CastRemoveBody),
        ReactionBody(super::ReactionBody),
        VerificationAddAddressBody(super::VerificationAddAddressBody),
        VerificationRemoveBody(super::VerificationRemoveBody),
        /// SignerAddBody signer_add_body = 11; // Deprecated
        UserDataBody(super::UserDataBody),
        /// SignerRemoveBody signer_remove_body = 13; // Deprecated
        LinkBody(super::LinkBody),
        UsernameProofBody(super::UserNameProof),
        FrameActionBody(super::FrameActionBody),
        /// Compaction messages
        LinkCompactStateBody(super::LinkCompactStateBody),
    }
}
/// * Adds metadata about a user 
#[derive(Encode, Decode)]
pub struct UserDataBody {
    /// Type of metadata
    pub r#type: i32,
    /// Value of the metadata
    pub value: alloc::string::String,
}
#[derive(Encode, Decode)]
pub struct Embed {
    pub embed: Option<embed::Embed>,
}
/// Nested message and enum types in `Embed`.
pub mod embed {
    use super::*;

        #[derive(Encode, Decode)]
    pub enum Embed {
        Url(alloc::string::String),
        CastId(super::CastId),
    }
}
/// * Adds a new Cast 
#[derive(Encode, Decode)]
pub struct CastAddBody {
    /// URLs to be embedded in the cast
    pub embeds_deprecated: alloc::vec::Vec<alloc::string::String>,
    /// Fids mentioned in the cast
    pub mentions: alloc::vec::Vec<u64>,
    /// Text of the cast
    pub text: alloc::string::String,
    /// Positions of the mentions in the text
    pub mentions_positions: alloc::vec::Vec<u32>,
    /// URLs or cast ids to be embedded in the cast
    pub embeds: alloc::vec::Vec<Embed>,
    /// Type of cast
    pub r#type: i32,
    pub parent: Option<cast_add_body::Parent>,
}
/// Nested message and enum types in `CastAddBody`.
pub mod cast_add_body {
    use super::*;

        #[derive(Encode, Decode)]
    pub enum Parent {
        /// Parent cast of the cast
        ParentCastId(super::CastId),
        /// Parent URL
        ParentUrl(alloc::string::String),
    }
}
/// * Removes an existing Cast 
#[derive(Encode, Decode)]
pub struct CastRemoveBody {
    /// Hash of the cast to remove
    pub target_hash: alloc::vec::Vec<u8>,
}
/// * Identifier used to look up a Cast 
#[derive(Encode, Decode)]
pub struct CastId {
    /// Fid of the user who created the cast
    pub fid: u64,
    /// Hash of the cast
    pub hash: alloc::vec::Vec<u8>,
}
/// * Adds or removes a Reaction from a Cast 
#[derive(Encode, Decode)]
pub struct ReactionBody {
    /// Type of reaction
    pub r#type: i32,
    pub target: Option<reaction_body::Target>,
}
/// Nested message and enum types in `ReactionBody`.
pub mod reaction_body {
    use super::*;

        #[derive(Encode, Decode)]
    pub enum Target {
        /// CastId of the Cast to react to
        TargetCastId(super::CastId),
        /// URL to react to
        TargetUrl(alloc::string::String),
    }
}
/// * Adds a Verification of ownership of an Address based on Protocol 
#[derive(Encode, Decode)]
pub struct VerificationAddAddressBody {
    /// Address being verified for a given Protocol
    pub address: alloc::vec::Vec<u8>,
    /// Signature produced by the user's address for a given Protocol
    pub claim_signature: alloc::vec::Vec<u8>,
    /// Hash of the latest Ethereum block when the signature was produced
    pub block_hash: alloc::vec::Vec<u8>,
    /// Type of verification. 0 = EOA, 1 = contract
    pub verification_type: u32,
    /// 0 for EOA verifications, 1 or 10 for contract verifications
    pub chain_id: u32,
    /// Protocol of the Verification
    pub protocol: i32,
}
/// * Removes a Verification of a given protocol 
#[derive(Encode, Decode)]
pub struct VerificationRemoveBody {
    /// Address of the Verification to remove
    pub address: alloc::vec::Vec<u8>,
    /// Protocol of the Verification to remove
    pub protocol: i32,
}
/// * Adds or removes a Link 
#[derive(Encode, Decode)]
pub struct LinkBody {
    /// Type of link, <= 8 characters
    pub r#type: alloc::string::String,
    /// User-defined timestamp that preserves original timestamp when message.data.timestamp needs to be updated for compaction
    pub display_timestamp: Option<u32>,
    pub target: Option<link_body::Target>,
}
/// Nested message and enum types in `LinkBody`.
pub mod link_body {
    use super::*;

        #[derive(Encode, Decode)]
    pub enum Target {
        /// The fid the link relates to
        TargetFid(u64),
    }
}
/// * A Compaction message for the Link Store 
#[derive(Encode, Decode)]
pub struct LinkCompactStateBody {
    /// Type of link, <= 8 characters
    pub r#type: alloc::string::String,
    pub target_fids: alloc::vec::Vec<u64>,
}
/// * A Farcaster Frame action 
#[derive(Encode, Decode)]
pub struct FrameActionBody {
    /// URL of the Frame triggering the action
    pub url: alloc::vec::Vec<u8>,
    /// The index of the button pressed (1-4)
    pub button_index: u32,
    /// The cast which contained the frame url
    pub cast_id: Option<CastId>,
    /// Text input from the user, if present
    pub input_text: alloc::vec::Vec<u8>,
    /// Serialized frame state value
    pub state: alloc::vec::Vec<u8>,
    /// Chain-specific transaction ID for tx actions
    pub transaction_id: alloc::vec::Vec<u8>,
    /// Chain-specific address for tx actions
    pub address: alloc::vec::Vec<u8>,
}
#[derive(Encode, Decode)]
pub struct UserNameProof {
    pub timestamp: u64,
    pub name: alloc::vec::Vec<u8>,
    pub owner: alloc::vec::Vec<u8>,
    pub signature: alloc::vec::Vec<u8>,
    pub fid: u64,
    pub r#type: i32,
}
/// * Type of hashing scheme used to produce a digest of MessageData 
#[derive(Encode, Decode)]
pub enum HashScheme {
    None = 0,
    /// Default scheme for hashing MessageData
    Blake3 = 1,
}
impl HashScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "HASH_SCHEME_NONE",
            Self::Blake3 => "HASH_SCHEME_BLAKE3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "HASH_SCHEME_NONE" => Some(Self::None),
            "HASH_SCHEME_BLAKE3" => Some(Self::Blake3),
            _ => None,
        }
    }
}
/// * Type of signature scheme used to sign the Message hash  
#[derive(Encode, Decode)]
pub enum SignatureScheme {
    None = 0,
    /// Ed25519 signature (default)
    Ed25519 = 1,
    /// ECDSA signature using EIP-712 scheme
    Eip712 = 2,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SIGNATURE_SCHEME_NONE",
            Self::Ed25519 => "SIGNATURE_SCHEME_ED25519",
            Self::Eip712 => "SIGNATURE_SCHEME_EIP712",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "SIGNATURE_SCHEME_NONE" => Some(Self::None),
            "SIGNATURE_SCHEME_ED25519" => Some(Self::Ed25519),
            "SIGNATURE_SCHEME_EIP712" => Some(Self::Eip712),
            _ => None,
        }
    }
}
/// * Type of the MessageBody 
#[derive(Encode, Decode)]
pub enum MessageType {
    None = 0,
    /// Add a new Cast
    CastAdd = 1,
    /// Remove an existing Cast
    CastRemove = 2,
    /// Add a Reaction to a Cast
    ReactionAdd = 3,
    /// Remove a Reaction from a Cast
    ReactionRemove = 4,
    /// Add a new Link
    LinkAdd = 5,
    /// Remove an existing Link
    LinkRemove = 6,
    /// Add a Verification of an Ethereum Address
    VerificationAddEthAddress = 7,
    /// Remove a Verification
    VerificationRemove = 8,
    ///   Deprecated
    ///   MESSAGE_TYPE_SIGNER_ADD = 9; // Add a new Ed25519 key pair that signs messages for a user
    ///   MESSAGE_TYPE_SIGNER_REMOVE = 10; // Remove an Ed25519 key pair that signs messages for a user
    ///
    /// Add metadata about a user
    UserDataAdd = 11,
    /// Add or replace a username proof
    UsernameProof = 12,
    /// A Farcaster Frame action
    FrameAction = 13,
    /// Link Compaction State Message
    LinkCompactState = 14,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MESSAGE_TYPE_NONE",
            Self::CastAdd => "MESSAGE_TYPE_CAST_ADD",
            Self::CastRemove => "MESSAGE_TYPE_CAST_REMOVE",
            Self::ReactionAdd => "MESSAGE_TYPE_REACTION_ADD",
            Self::ReactionRemove => "MESSAGE_TYPE_REACTION_REMOVE",
            Self::LinkAdd => "MESSAGE_TYPE_LINK_ADD",
            Self::LinkRemove => "MESSAGE_TYPE_LINK_REMOVE",
            Self::VerificationAddEthAddress => "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS",
            Self::VerificationRemove => "MESSAGE_TYPE_VERIFICATION_REMOVE",
            Self::UserDataAdd => "MESSAGE_TYPE_USER_DATA_ADD",
            Self::UsernameProof => "MESSAGE_TYPE_USERNAME_PROOF",
            Self::FrameAction => "MESSAGE_TYPE_FRAME_ACTION",
            Self::LinkCompactState => "MESSAGE_TYPE_LINK_COMPACT_STATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "MESSAGE_TYPE_NONE" => Some(Self::None),
            "MESSAGE_TYPE_CAST_ADD" => Some(Self::CastAdd),
            "MESSAGE_TYPE_CAST_REMOVE" => Some(Self::CastRemove),
            "MESSAGE_TYPE_REACTION_ADD" => Some(Self::ReactionAdd),
            "MESSAGE_TYPE_REACTION_REMOVE" => Some(Self::ReactionRemove),
            "MESSAGE_TYPE_LINK_ADD" => Some(Self::LinkAdd),
            "MESSAGE_TYPE_LINK_REMOVE" => Some(Self::LinkRemove),
            "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS" => Some(Self::VerificationAddEthAddress),
            "MESSAGE_TYPE_VERIFICATION_REMOVE" => Some(Self::VerificationRemove),
            "MESSAGE_TYPE_USER_DATA_ADD" => Some(Self::UserDataAdd),
            "MESSAGE_TYPE_USERNAME_PROOF" => Some(Self::UsernameProof),
            "MESSAGE_TYPE_FRAME_ACTION" => Some(Self::FrameAction),
            "MESSAGE_TYPE_LINK_COMPACT_STATE" => Some(Self::LinkCompactState),
            _ => None,
        }
    }
}
/// * Farcaster network the message is intended for 
#[derive(Encode, Decode)]
pub enum FarcasterNetwork {
    None = 0,
    /// Public primary network
    Mainnet = 1,
    /// Public test network
    Testnet = 2,
    /// Private test network
    Devnet = 3,
}
impl FarcasterNetwork {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FARCASTER_NETWORK_NONE",
            Self::Mainnet => "FARCASTER_NETWORK_MAINNET",
            Self::Testnet => "FARCASTER_NETWORK_TESTNET",
            Self::Devnet => "FARCASTER_NETWORK_DEVNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "FARCASTER_NETWORK_NONE" => Some(Self::None),
            "FARCASTER_NETWORK_MAINNET" => Some(Self::Mainnet),
            "FARCASTER_NETWORK_TESTNET" => Some(Self::Testnet),
            "FARCASTER_NETWORK_DEVNET" => Some(Self::Devnet),
            _ => None,
        }
    }
}
/// * Type of UserData 
#[derive(Encode, Decode)]
pub enum UserDataType {
    None = 0,
    /// Profile Picture for the user
    Pfp = 1,
    /// Display Name for the user
    Display = 2,
    /// Bio for the user
    Bio = 3,
    /// URL of the user
    Url = 5,
    /// Preferred Name for the user
    Username = 6,
}
impl UserDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "USER_DATA_TYPE_NONE",
            Self::Pfp => "USER_DATA_TYPE_PFP",
            Self::Display => "USER_DATA_TYPE_DISPLAY",
            Self::Bio => "USER_DATA_TYPE_BIO",
            Self::Url => "USER_DATA_TYPE_URL",
            Self::Username => "USER_DATA_TYPE_USERNAME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "USER_DATA_TYPE_NONE" => Some(Self::None),
            "USER_DATA_TYPE_PFP" => Some(Self::Pfp),
            "USER_DATA_TYPE_DISPLAY" => Some(Self::Display),
            "USER_DATA_TYPE_BIO" => Some(Self::Bio),
            "USER_DATA_TYPE_URL" => Some(Self::Url),
            "USER_DATA_TYPE_USERNAME" => Some(Self::Username),
            _ => None,
        }
    }
}
/// * Type of cast 
#[derive(Encode, Decode)]
pub enum CastType {
    Cast = 0,
    LongCast = 1,
}
impl CastType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Cast => "CAST",
            Self::LongCast => "LONG_CAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "CAST" => Some(Self::Cast),
            "LONG_CAST" => Some(Self::LongCast),
            _ => None,
        }
    }
}
/// * Type of Reaction 
#[derive(Encode, Decode)]
pub enum ReactionType {
    None = 0,
    /// Like the target cast
    Like = 1,
    /// Share target cast to the user's audience
    Recast = 2,
}
impl ReactionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "REACTION_TYPE_NONE",
            Self::Like => "REACTION_TYPE_LIKE",
            Self::Recast => "REACTION_TYPE_RECAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "REACTION_TYPE_NONE" => Some(Self::None),
            "REACTION_TYPE_LIKE" => Some(Self::Like),
            "REACTION_TYPE_RECAST" => Some(Self::Recast),
            _ => None,
        }
    }
}
/// * Type of Protocol to disambiguate verification addresses 
#[derive(Encode, Decode)]
pub enum Protocol {
    Ethereum = 0,
    Solana = 1,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ethereum => "PROTOCOL_ETHEREUM",
            Self::Solana => "PROTOCOL_SOLANA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "PROTOCOL_ETHEREUM" => Some(Self::Ethereum),
            "PROTOCOL_SOLANA" => Some(Self::Solana),
            _ => None,
        }
    }
}
#[derive(Encode, Decode)]
pub enum UserNameType {
    UsernameTypeNone = 0,
    UsernameTypeFname = 1,
    UsernameTypeEnsL1 = 2,
}
impl UserNameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UsernameTypeNone => "USERNAME_TYPE_NONE",
            Self::UsernameTypeFname => "USERNAME_TYPE_FNAME",
            Self::UsernameTypeEnsL1 => "USERNAME_TYPE_ENS_L1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> Option<Self> {
        match value {
            "USERNAME_TYPE_NONE" => Some(Self::UsernameTypeNone),
            "USERNAME_TYPE_FNAME" => Some(Self::UsernameTypeFname),
            "USERNAME_TYPE_ENS_L1" => Some(Self::UsernameTypeEnsL1),
            _ => None,
        }
    }
}
